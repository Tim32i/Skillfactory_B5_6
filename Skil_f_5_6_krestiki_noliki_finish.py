import random

tree_lst = [0] * 9                               # список деревьев ходов от первого хода, вначале пустой - заполнен нолями

main_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]          # список номеров ячеек


def check_victory(lst_cells):
    ''' определяет победителя, 1 - крестики, 0 - нолики, None - нет победителя
        параметр lst_cells  - список с номерами ячеек поля (от 1 до 9) с виртуальными ходами:
        0 - проставлен нолик, 1 - проставлен крестик, 10 - пустая ячейка
    '''
    d1  = lst_cells[0] + lst_cells[4] + lst_cells[8] # 1-я диагональ сумма - или 3, или 0 или нет победы
    if d1 == 3:                                      # если сумма 3
        return 1                                     # возвращаем победу крестиков
    elif d1 == 0:                                    # если сумма 0   
        return 0                                     # возвращаем победу ноликов
                                                     # если нет победы - идем дальше
    d2 = lst_cells[6] + lst_cells[4] + lst_cells[2]  # 2-я диагональ 
    if d2 == 3:
        return 1                                       
    elif d2 == 0:
        return 0
    r1 = lst_cells[0 ]+ lst_cells[1] + lst_cells[2]  # 1-й ряд 
    if r1 == 3:
        return 1                                       
    elif r1 == 0:
        return 0
    r2 = lst_cells[3] + lst_cells[4] + lst_cells[5]  # 2-й ряд 
    if r2 == 3:
        return 1                                       
    elif r2 == 0:
        return 0
    r3 = lst_cells[6] + lst_cells[7] + lst_cells[8]   # 3-й ряд 
    if r3 == 3:
        return 1                                       
    elif r3 == 0:
        return 0
    c1 = lst_cells[0] + lst_cells[3] + lst_cells[6]   # 1-й столбец 
    if c1 == 3:
        return 1                                       
    elif c1 == 0:
        return 0
    c2 = lst_cells[1]+ lst_cells[4] + lst_cells[7]   # 2-й столбец 
    if c2 == 3:
        return 1                                       
    elif c2 == 0:
        return 0
    c3 = lst_cells[2]+ lst_cells[5] + lst_cells[8]   # 3-й столбец
    if c3 == 3:
        return 1                                       
    elif c3 == 0:
        return 0
    
    return None                                      # прошли все проверки и не нашли победы или поражения, возврат None

def mark_victory(lst_vict, player):
    ''' преобразует для текущего узла список побед нижних узлов в одно значение по правилу:
        победа считается относительно первого игрока (крестики) 
        если текущий игрок - крестики (player = 1):
                  возврат 2(победа) если весь список из 2 (любой след ход нолика победный для крестика)
           иначе  возврат 0(поражение) если хотя бы один 0 в списке (предполагается что нолик умный и на след ходу обязательно использует шанс,
                         если он есть и найдет ход, ведущий к поражению крестика)
           иначе  возврат 1(ничья) если в списке нет 0 и есть хотя бы одна единичка (если нет поражений для крестика,
                  нолик хотя бы не даст себя обыграть) 
               
        если текущий игрок - нолики (player = 0):
                  возврат 2(победа) если хотя бы одна 2 в списке (предполагается что крестик умный и на след ходу обязательно использует шанс,
                         если он есть и найдет ход, ведущий к своей победе)
            иначе возврат 0(поражение) если весь список из 0 (любой след ход крестика ведет к его поражению)
            иначе возврат 1(ничья) если нет 2, и есть хоть одна 1, крестик хотя бы не даст себя обыграть (выберет ничейный вариант)         
    '''
    if player:
        if all(a == 2 for a in lst_vict):
            return 2
        elif any(a == 0 for a in lst_vict):
            return 0
        else:
            return 1
    else:
        if any(a == 2 for a in lst_vict):
            return 2
        elif all(a == 0 for a in lst_vict):
            return 0
        else:
            return 1
        
def create_tree(first_step):
    '''Построение дерева ходов от 1-го хода first_step '''

    tree = [10 + first_step, [], []]                 # добавляем в дерево верхушку (первый ход), список:
                                                     # 1 - номер узла(уровень*10 + номерячейки хода)
                                                     # 2 - список узлов - детей (пока что пустой)
                                                     # 3 - список побед 1-го игрока(крестики) в узлах-детях: 2 - победа, 1 - ничья, 0 - поражение
                                                     #     в конце обработки будет преобразован в признак победы (2, 0 или 1 )
    set_lst = set(main_list)                         # список номеров ячеек в виде множества (удобно вычислять список оставшихся ходов)
                                                     # вычитанием списка виртуальных сделанных ходов
    sp_h = []                                        # список виртуальных ходов, с номерами ячеек на поле (от 1 до 9)
    sp_h.append(first_step)                          # добавляем 1-й ход в список виртуальных ходов
    lst_cells = [10] * 9                             # список ячеек игрового поля: 0 - нолик, 1 - крестик, 10 - пустая ячейка
                                                     # вначале все ячейки пустые (заполнены десятками)
    lst_cells[first_step -1] = 1                     # заносим первый ход крестика
    level = 2                                        # номер текущего уровня
    work_lst = list(set_lst.difference(sp_h))        # тек раб список - список возможных ходов на текущем уровне
    work_lst[0] = work_lst[0] + 10                   # первому елементу раб списка проставлеям признак (>10), чтобы учитывать это при движении
                                                     # виртуальных ходов (если 1-й елемент - просто добавляем ход, если не 1-й, сначала убираем
                                                     # последний ход, только затем вместо него добавляем новый)                                                       
    work_parent = tree                               # узел-родитель узлов текущего уровня
    stek_lst = []                                    # стек раб списков
    stek_parent = []                                 # стек узлов-родителей
   
    while True:   
            
        if not work_lst:                                             # проверка раб список пуст                
            level -= 1                                               # повышаем уровень
            work_parent[2] = mark_victory(work_parent[2], level % 2) # перед уходом на верх уровень обрабатываем список побед для узлов тек уровня,
                                                                     # т.к. список всех узлов-детей сформирован.
                                                                     # Преобразуем список побед в признак и проставляем его родителю текущих узлов                                                                 
                                                                     # победы(2), поражения(0) или ничьей(1),
                                                                     # level - нечетный для крестиков, четный для ноликов (крестики всегда начинают)
                    
            if level == 1:                                    # если первый уровень: 
                break                                         # завершение, дерево построено
            else:                                               
                stek_parent[-1][2].append(work_parent[2])     # добавляем признак победы в список побед предыдущего родителя, который лежит последним
                                                              # в стеке родителей, только если не первый уровень, на первом уровне стек родителей пустой.
                work_lst = stek_lst.pop(-1)                   # взять из стека раб списков предыдущий раб список (LIFO),
                work_parent = stek_parent.pop(-1)             # взять из стека предыдущего родителя, (LIFO)
                last_step = sp_h.pop(-1)                      # убираем из списка виртуальных ходов последний ход
                lst_cells[last_step - 1] = 10                 # и очищаем ячейку последнего хода на поле (10 - пустая ячейка)
            
        else:                                                 # раб список непустой
            elem = work_lst.pop(0)                            # берем в обработку очередной елемент раб списка, с удалением его из списка
            if elem < 10:                                     # проверяем, что елемент списка не первый, если да, то:
                last_step = sp_h.pop(-1)                      # сначала убираем последний ход
                lst_cells[last_step - 1] = 10                 # и очищаем ячейку последнего хода на поле (10 - пустая ячейка)
            else:                                             # если первый елемент
                 elem -= 10                                   # то приводим в нормальный вид(-10)

            sp_h.append(elem)                                 # добавляем ход в список виртуальных ходов
            lst_cells[elem - 1] = level % 2                   # заполняем ячейку игрового поля: нечетный уровень - ход крестика - 1,
                                                              # четный уровень - ход нолика - 0.
                        
            work_parent[1].append([level * 10 + elem, [], []])# формируем на его основе новый узел на текущем уровне 
                                                              # work_parent[1] - список узлов тек уровня - детей родителя work_parent
            victory = check_victory(lst_cells)                # получаем из функции check_victory() проверку на победу 
                                                              # 0 - победа ноликов, 1 - победа крестиков, None - нет победы
            # Проверяем два варианта - или узел конечный(чья то победа или все ячейки заполнены),
            # или нужно провалиться ниже (нет победы и есть свободные ячейки) 
            
            if victory is not None:                           # проверяем что есть чья то победа
                work_parent[1][-1][2] = victory * 2           # проставляем в тек узле признак победы: 2 - победа, 0 - поражение
                                                              # в тек узле третий елемент (список побед нижних узлов, пустой, и нижних узлов не будет,
                                                              # т.к. на этом узле конец игры, чья то победа) заменяется признаком победы
                work_parent[2].append(victory * 2)            # добавляем этот же признак победы в список побед в родителе
                
            else:                                             # нет победы
                if len(sp_h) == 9:                            # проверяем что все ячейки заполнены
                    work_parent[1][-1][2] = 1                 # если да (никто не победил и нет свободных ячеек) добавляем в новый узел признак ничьей
                    work_parent[2].append(1)                  # добавляем этот же признак ничьей в список побед в родителе
                    
                else:                                         # нет победы и не все ячейки заполнены - проваливаемся на уровень ниже:
                    level +=1                                 # понижем уровень,
                    stek_parent.append(work_parent)           # складываем в стек родителя тек узлов,
                    stek_lst.append(work_lst)                 # и тек. раб. список                
                    work_parent = work_parent[1][-1]          # переуказываем тек родителя на только что созданный узел, тепереь он - тек родитель 
                    work_lst = list(set_lst.difference(sp_h)) # формируем тек раб список возможных ходов с этого уровня
                    work_lst[0] += 10                         # первому елементу раб списка проставлеям признак > 10,признак первого елемента
 
        # уходим на следующую итерацию
        
    return tree                                               # возврат построенного дерева


# Главный блок программы

steps_lst = []         # список сделанных ходов
cells_lst = [10] * 9   # список ячеек игрового поля: 0 - нолик, 1 - крестик, 10 - пустая ячейка
                       # вначале все ячейки пустые (заполнены десятками)
vict_priority_lst = [] # список побед, поражений, ничьих по приоритету поиска ([2, 1, 0] для крестиков, [0, 1, 2] для ноликов)
current_node = []      # узел в дереве для текущего хода

# функции

def display_matrix(cells_lst):
    '''вывод игрового поля с текущими сделанными ходами'''
    print()
    matrix_print = [['     ' for j in range(3)] for i in range(9)]                   # матрица строк 9 x 3, для каждой ячейки - 3 строки, вначале пустая
    for i in range(9):                                                               # проходим по ячейкам
        if cells_lst[i] == 1:                                                        # и формируем печатные строки в зав-сти от значения в ячейках 1 или 0
            matrix_print[i][1] = ' \/  '                                             # значения 10 (пустая ячейка) просто игнорируем, останутся 
            matrix_print[i][2] = ' /\  '                                             # пустые печатныестроки (5 пробелов)
        elif cells_lst[i] == 0:
            matrix_print[i][0] = '  _  '
            matrix_print[i][1] = ' / \ '
            matrix_print[i][2] = ' \_/ '
    
    for i in range(3):                                                                     # вывод на печать построчно
        print(matrix_print[0][i] + '|' + matrix_print[1][i] + '|' + matrix_print[2][i])
    print('-----------------')
    for i in range(3):
        print(matrix_print[3][i] + '|' + matrix_print[4][i] + '|' + matrix_print[5][i])
    print('-----------------')
    for i in range(3):
        print(matrix_print[6][i] + '|' + matrix_print[7][i] + '|' + matrix_print[8][i])


def user_move():
    '''
       Реализует ход игрока
       спросить у игрока куда ходить в виде одного числа от 1 до 9,
       проверить легитмность, число должно быть в списке - list(set(main_list).difference(steps_lst))     
       вернуть число - выбор игрока
    '''
    global tree_lst
    global current_node
    lst_remain = list(set(main_list).difference(steps_lst))                 # получаем список оставшихся ходов
    while True:                                                             # зацикливаем пока не будет правильного хода от пользователя
        new_step = input('Делайте ход, (из ' +
                         ','.join([str(elem) for elem in lst_remain]) +
                         ' ячеек): ')
        if new_step.isdigit():                                              # проверка на числовой ввод
            new_step = int(new_step)
        else:
            print('Оошибка ввода. Попробуйте еще раз.')
            continue
        if new_step not in lst_remain:                                    # проверка на недопустимый ход
            print('Надо выбрать из ', *lst_remain)
            continue
                                                                          # правильный ввод, выходим из цикла ввода
                                                                         
                                                                          # обрабатываем правильный ввод
        if not steps_lst:                                                 # если это первый ход:
            if tree_lst[new_step - 1] == 0:                               # проверка, что дерево для данного первого хода не построено
                current_node = create_tree(new_step)                      # создаем и указываем current_node на созданное дерево
            else:                                                         # если дерево уже есть
                current_node = tree_lst[new_step - 1]                     # указываем current_node на него
        else:                                                             # иначе (если это не 1-й ход):
            for i in range(len(current_node[1])):                         # проходим по детям тек узла
                if new_step == current_node[1][i][0] % 10:                # ищем узел соотв-щий сделанному ходу
                    ind = i
                    break                
            current_node = current_node[1][ind]                           # переуказываем тек узел на нижний узел соотв ходу
        return new_step                                                   # возврат нового хода

def comp_move():
    '''
       Реализует ход компьютера
       если это первый ход - проверить в списоке деревьев наличие уже построенного дерева в соответствующей
      позиции первого хода, если есть - использовать конкретное дерево, если нет - построить его (create_tree)
      на основе узла предыд хода взять список побед и сформировать 3 списка - побед, ничьих и поражений
      возврат числа - выбранного хода
    '''
    global current_node
    global tree_lst

    if not steps_lst:                                                                # если это первый ход игры и первый для компа:
        new_step = random.choice(main_list)                                          # выбираем случайный ход
                                                                                     # фора пользователю, дальнейшие ходы будут оптимальными
        if tree_lst[new_step - 1] == 0:                                              # проверка, что дерево для данного первого хода не построено
            tree_lst[new_step - 1] = create_tree(new_step)                           # создаем новое дерево и добавляем его в список деревьев
        current_node = tree_lst[new_step - 1]                                        # указываем current_node на него
        return new_step                                                              # возврат нового хода
    else:                                                                            # уже были ходы - ищем новый ход в дереве ходов
        if len(steps_lst) == 1:                                                      # фора пользователю - тек ход - первый для компа (второй ход игры,
                                                                                     # а первый уже сделан пользователем)
            current_node = random.choice(current_node[1])                            # рандомно выбираем узел-кандидат среди детей тек узла                              
        else:                                                                        # не первый ход компа - ищем оптимально
            for prio in vict_priority_lst:                                           # идем по списку приоритетов
                nodes_cand = [elem for elem in current_node[1] if elem[2] == prio]   # строим список узлов кандидатов
                                                                                     # из детей тек узла по приоритету побед, поражений
                if nodes_cand:                                                       # если полученный список непустой
                    current_node = random.choice(nodes_cand)                         # рандомно выбираем узел-кандидат
                    break                                                            # прекращаем дальнейший поиск
                
        return current_node[0] % 10                                                  # возврат номера нового хода                       


# Основная логика программы

print('Программа крестики-нолики')
print('Ходы выбираются в виде чисел от 1 до 9 по номерам ячеек:')
print(
    '''
      1 | 2 | 3
     -----------
      4 | 5 | 6
     -----------
      7 | 8 | 9
    '''
)
print()

while True:                                      # цикл игр
    game_over = input('Играем?: y or n ')
    if game_over == 'n':
        break                                    # выход из программы, игрок не хочет больше играть
    else:
        # начинаем игру
        while True:                                # пока пользователь не сделает выбор правильно - зацикливаем
            user_choice = input('Выберите крестики или нолики, 1 или 0 : ')
            if user_choice == '1' or user_choice == '0':
                user_choice = int(user_choice)
                break
            else:
                print('1 или 0 !')

        if user_choice:                             # если пользователь за крестиков, 
            move_func_lst = [comp_move, user_move]  # нечетные ходы - его (ндекс -1), а четные - компьютера (индекс - 0)
            vict_priority_lst = [0, 1, 2]           # в приоритете у программы - поражения крестиков
        else:
            move_func_lst = [user_move, comp_move]  # наоборот
            vict_priority_lst = [2, 1, 0]           # в приоритете у программы - победы крестиков

        steps_lst = []                                                             # очищаем спмсок сделанных ходов
        cells_lst = [10] * 9                                                       # очищаем список ячеек игрового поля, 10 - пустая ячейка
        step_count = 1                                                             # счетчик ходов
        current_node = []                                                          # тек узел в дереве ходов
        display_matrix(cells_lst)                                                  # показываем текущее пустое поле
        
        while (vict := check_victory(cells_lst)) is None and step_count <= 9:      # играем пока нет чьей то победы и поле не заполнено            
                                                                                   # рез-т победы - в vict, потом понадобится
            rez_step = move_func_lst[step_count%2]()                               # вызов функции хода, в зав-ти от того чей ход            
            steps_lst.append(rez_step)                                             # добавляем ход в список ходов            
            cells_lst[rez_step - 1] = step_count % 2                               # проставляем 1 или 0 (в зав-ти от четности хода)
                                                                                   # в соотв позицию в списке ячеек, с учетом индекса            
            display_matrix(cells_lst)                                              # показываем текущее поле
            print()
            step_count += 1                                                        # увеличиваем счетчик хода
            
        if vict == 1:
            print('Крестики выиграли')
        elif vict == 0:
            print('Нолики выиграли')
        else:
            print('Ничья')
        print()
            
            
        
               
           
        
    




